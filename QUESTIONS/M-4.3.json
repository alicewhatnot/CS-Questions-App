[
  {
    "question": "What is the definition of an algorithm?",
    "marks": 1,
    "mark_scheme": "A finite sequence of unambiguous instructions to solve a problem",
    "topic": "Fundamentals of algorithms",
    "subtopic": "Nature of algorithms",
    "question_type": "multiple_choice",
    "wrong_choices": ["A programming language", "A computer program", "A flowchart diagram"]
  },
  {
    "question": "Which of the following best describes abstraction in algorithms?",
    "marks": 1,
    "mark_scheme": "Removing unnecessary details to focus on the essential features",
    "topic": "Fundamentals of algorithms",
    "subtopic": "Nature of algorithms",
    "question_type": "multiple_choice",
    "wrong_choices": ["Breaking a problem into smaller tasks", "Tracing through pseudocode", "Comparing algorithm speeds"]
  },
  {
    "question": "Which of the following is the best description of decomposition?",
    "marks": 1,
    "mark_scheme": "Breaking a problem into smaller subproblems",
    "topic": "Fundamentals of algorithms",
    "subtopic": "Nature of algorithms",
    "question_type": "multiple_choice",
    "wrong_choices": ["Writing pseudocode", "Abstracting away details", "Measuring algorithm complexity"]
  },
  {
    "question": "What does algorithm trace table testing involve?",
    "marks": 1,
    "mark_scheme": "Tracking variable values step by step through execution",
    "topic": "Fundamentals of algorithms",
    "subtopic": "Tracing algorithms",
    "question_type": "multiple_choice",
    "wrong_choices": ["Running the algorithm on a compiler", "Measuring execution time", "Drawing flowcharts"]
  },
  {
    "question": "What is meant by the efficiency of an algorithm?",
    "marks": 1,
    "mark_scheme": "How well it uses time and resources",
    "topic": "Fundamentals of algorithms",
    "subtopic": "Comparing efficiency",
    "question_type": "multiple_choice",
    "wrong_choices": ["How easy it is to read", "How often it produces errors", "How much it costs to run"]
  },
  {
    "question": "Which notation is used to describe the growth rate of an algorithm?",
    "marks": 1,
    "mark_scheme": "Big-O notation",
    "topic": "Fundamentals of algorithms",
    "subtopic": "Big-O notation",
    "question_type": "multiple_choice",
    "wrong_choices": ["Binary notation", "Hexadecimal notation", "Prefix notation"]
  },
  {
    "question": "Which Big-O class represents constant time?",
    "marks": 1,
    "mark_scheme": "O(1)",
    "topic": "Fundamentals of algorithms",
    "subtopic": "Big-O notation",
    "question_type": "multiple_choice",
    "wrong_choices": ["O(n)", "O(log n)", "O(n^2)"]
  },
  {
    "question": "Which Big-O class represents logarithmic time?",
    "marks": 1,
    "mark_scheme": "O(log n)",
    "topic": "Fundamentals of algorithms",
    "subtopic": "Big-O notation",
    "question_type": "multiple_choice",
    "wrong_choices": ["O(1)", "O(n)", "O(n^2)"]
  },
  {
    "question": "Which Big-O class represents quadratic time?",
    "marks": 1,
    "mark_scheme": "O(n^2)",
    "topic": "Fundamentals of algorithms",
    "subtopic": "Big-O notation",
    "question_type": "multiple_choice",
    "wrong_choices": ["O(1)", "O(n)", "O(log n)"]
  },
  {
    "question": "Which search algorithm checks each item in sequence until found?",
    "marks": 1,
    "mark_scheme": "Linear search",
    "topic": "Fundamentals of algorithms",
    "subtopic": "Searching algorithms",
    "question_type": "multiple_choice",
    "wrong_choices": ["Binary search", "Bubble sort", "Merge sort"]
  },
  {
    "question": "Which search algorithm requires the data to be sorted?",
    "marks": 1,
    "mark_scheme": "Binary search",
    "topic": "Fundamentals of algorithms",
    "subtopic": "Searching algorithms",
    "question_type": "multiple_choice",
    "wrong_choices": ["Linear search", "Bubble sort", "Quick sort"]
  },
  {
    "question": "What is the average time complexity of a binary search?",
    "marks": 1,
    "mark_scheme": "O(log n)",
    "topic": "Fundamentals of algorithms",
    "subtopic": "Searching algorithms",
    "question_type": "multiple_choice",
    "wrong_choices": ["O(1)", "O(n)", "O(n log n)"]
  },
  {
    "question": "Which sorting algorithm repeatedly swaps adjacent items if they are in the wrong order?",
    "marks": 1,
    "mark_scheme": "Bubble sort",
    "topic": "Fundamentals of algorithms",
    "subtopic": "Sorting algorithms",
    "question_type": "multiple_choice",
    "wrong_choices": ["Merge sort", "Quick sort", "Insertion sort"]
  },
  {
    "question": "Which sorting algorithm splits the list in half, sorts each half, and then merges them?",
    "marks": 1,
    "mark_scheme": "Merge sort",
    "topic": "Fundamentals of algorithms",
    "subtopic": "Sorting algorithms",
    "question_type": "multiple_choice",
    "wrong_choices": ["Bubble sort", "Quick sort", "Insertion sort"]
  },
  {
    "question": "Which sorting algorithm chooses a pivot element and partitions the list?",
    "marks": 1,
    "mark_scheme": "Quick sort",
    "topic": "Fundamentals of algorithms",
    "subtopic": "Sorting algorithms",
    "question_type": "multiple_choice",
    "wrong_choices": ["Merge sort", "Bubble sort", "Selection sort"]
  },
  {
    "question": "Which sorting algorithm builds a sorted list one item at a time by inserting elements in order?",
    "marks": 1,
    "mark_scheme": "Insertion sort",
    "topic": "Fundamentals of algorithms",
    "subtopic": "Sorting algorithms",
    "question_type": "multiple_choice",
    "wrong_choices": ["Bubble sort", "Merge sort", "Quick sort"]
  },
  {
    "question": "What is the average case time complexity of bubble sort?",
    "marks": 1,
    "mark_scheme": "O(n^2)",
    "topic": "Fundamentals of algorithms",
    "subtopic": "Sorting algorithms",
    "question_type": "multiple_choice",
    "wrong_choices": ["O(n)", "O(log n)", "O(n log n)"]
  },
  {
    "question": "What is the average case time complexity of merge sort?",
    "marks": 1,
    "mark_scheme": "O(n log n)",
    "topic": "Fundamentals of algorithms",
    "subtopic": "Sorting algorithms",
    "question_type": "multiple_choice",
    "wrong_choices": ["O(n)", "O(n^2)", "O(1)"]
  },
  {
    "question": "What is the worst-case time complexity of quick sort?",
    "marks": 1,
    "mark_scheme": "O(n^2)",
    "topic": "Fundamentals of algorithms",
    "subtopic": "Sorting algorithms",
    "question_type": "multiple_choice",
    "wrong_choices": ["O(n log n)", "O(log n)", "O(1)"]
  },
  {
    "question": "Which sorting algorithm is considered stable?",
    "marks": 1,
    "mark_scheme": "Merge sort",
    "topic": "Fundamentals of algorithms",
    "subtopic": "Sorting algorithms",
    "question_type": "multiple_choice",
    "wrong_choices": ["Quick sort", "Selection sort", "Heap sort"]
  },
  {
    "question": "Which graph traversal explores as far as possible before backtracking?",
    "marks": 1,
    "mark_scheme": "Depth-first search",
    "topic": "Fundamentals of algorithms",
    "subtopic": "Graph traversal",
    "question_type": "multiple_choice",
    "wrong_choices": ["Breadth-first search", "Binary search", "Linear search"]
  },
  {
    "question": "Which graph traversal explores all neighbours before moving deeper?",
    "marks": 1,
    "mark_scheme": "Breadth-first search",
    "topic": "Fundamentals of algorithms",
    "subtopic": "Graph traversal",
    "question_type": "multiple_choice",
    "wrong_choices": ["Depth-first search", "Binary search", "Insertion sort"]
  },
  {
    "question": "Which data structure is typically used to implement depth-first search?",
    "marks": 1,
    "mark_scheme": "Stack",
    "topic": "Fundamentals of algorithms",
    "subtopic": "Graph traversal",
    "question_type": "multiple_choice",
    "wrong_choices": ["Queue", "Array", "Heap"]
  },
  {
    "question": "Which data structure is typically used to implement breadth-first search?",
    "marks": 1,
    "mark_scheme": "Queue",
    "topic": "Fundamentals of algorithms",
    "subtopic": "Graph traversal",
    "question_type": "multiple_choice",
    "wrong_choices": ["Stack", "Linked list", "Hash table"]
  },
  {
    "question": "Which algorithm finds the shortest path in a weighted graph with non-negative weights?",
    "marks": 1,
    "mark_scheme": "Dijkstra’s algorithm",
    "topic": "Fundamentals of algorithms",
    "subtopic": "Shortest path",
    "question_type": "multiple_choice",
    "wrong_choices": ["Prim’s algorithm", "Kruskal’s algorithm", "Bubble sort"]
  },
  {
    "question": "Which algorithm finds a minimum spanning tree of a graph?",
    "marks": 1,
    "mark_scheme": "Prim’s algorithm",
    "topic": "Fundamentals of algorithms",
    "subtopic": "Minimum spanning tree",
    "question_type": "multiple_choice",
    "wrong_choices": ["Dijkstra’s algorithm", "Binary search", "Merge sort"]
  },
  {
    "question": "Which other algorithm also finds a minimum spanning tree?",
    "marks": 1,
    "mark_scheme": "Kruskal’s algorithm",
    "topic": "Fundamentals of algorithms",
    "subtopic": "Minimum spanning tree",
    "question_type": "multiple_choice",
    "wrong_choices": ["Depth-first search", "Insertion sort", "Bubble sort"]
  },
  {
    "question": "What is the main advantage of quick sort compared to bubble sort?",
    "marks": 1,
    "mark_scheme": "It is more efficient on average",
    "topic": "Fundamentals of algorithms",
    "subtopic": "Sorting algorithms",
    "question_type": "multiple_choice",
    "wrong_choices": ["It always requires less memory", "It is easier to code", "It guarantees stability"]
  },
  {
    "question": "Which type of problem-solving technique tries all possibilities to find the best solution?",
    "marks": 1,
    "mark_scheme": "Brute force",
    "topic": "Fundamentals of algorithms",
    "subtopic": "Algorithm design",
    "question_type": "multiple_choice",
    "wrong_choices": ["Greedy", "Divide and conquer", "Dynamic programming"]
  },
  {
    "question": "Which algorithm design technique breaks problems into smaller overlapping subproblems?",
    "marks": 1,
    "mark_scheme": "Dynamic programming",
    "topic": "Fundamentals of algorithms",
    "subtopic": "Algorithm design",
    "question_type": "multiple_choice",
    "wrong_choices": ["Greedy", "Brute force", "Linear search"]
  },
  {
    "question": "Which algorithm design technique builds a solution by choosing the best option at each step?",
    "marks": 1,
    "mark_scheme": "Greedy algorithm",
    "topic": "Fundamentals of algorithms",
    "subtopic": "Algorithm design",
    "question_type": "multiple_choice",
    "wrong_choices": ["Dynamic programming", "Divide and conquer", "Brute force"]
  },
  {
    "question": "Which algorithmic strategy does merge sort use?",
    "marks": 1,
    "mark_scheme": "Divide and conquer",
    "topic": "Fundamentals of algorithms",
    "subtopic": "Algorithm design",
    "question_type": "multiple_choice",
    "wrong_choices": ["Greedy", "Brute force", "Dynamic programming"]
  },
  {
    "question": "Which factor is most important in determining time complexity?",
    "marks": 1,
    "mark_scheme": "The size of the input",
    "topic": "Fundamentals of algorithms",
    "subtopic": "Complexity",
    "question_type": "multiple_choice",
    "wrong_choices": ["The programming language", "The compiler used", "The variable names chosen"]
  },
  {
    "question": "Which complexity class is generally the most efficient?",
    "marks": 1,
    "mark_scheme": "O(1)",
    "topic": "Fundamentals of algorithms",
    "subtopic": "Complexity",
    "question_type": "multiple_choice",
    "wrong_choices": ["O(log n)", "O(n)", "O(n^2)"]
  },
  {
    "question": "Which algorithm is guaranteed to find the optimal path in a weighted graph if all edges are non-negative?",
    "marks": 1,
    "mark_scheme": "Dijkstra’s algorithm",
    "topic": "Fundamentals of algorithms",
    "subtopic": "Shortest path",
    "question_type": "multiple_choice",
    "wrong_choices": ["Breadth-first search", "Depth-first search", "Quick sort"]
  },
  {
    "question": "Which algorithm is often used for pathfinding in games?",
    "marks": 1,
    "mark_scheme": "A* algorithm",
    "topic": "Fundamentals of algorithms",
    "subtopic": "Shortest path",
    "question_type": "multiple_choice",
    "wrong_choices": ["Bubble sort", "Insertion sort", "Merge sort"]
  },
  {
    "question": "What does Big-O notation describe?",
    "marks": 1,
    "mark_scheme": "The upper bound of an algorithm’s growth rate",
    "topic": "Fundamentals of algorithms",
    "subtopic": "Big-O notation",
    "question_type": "multiple_choice",
    "wrong_choices": ["The exact run time", "The memory used", "The average case only"]
  },
  {
    "question": "Which best describes optimisation in algorithms?",
    "marks": 1,
    "mark_scheme": "Finding the most efficient solution to a problem",
    "topic": "Fundamentals of algorithms",
    "subtopic": "Optimisation",
    "question_type": "multiple_choice",
    "wrong_choices": ["Making code shorter", "Removing variables", "Using fewer functions"]
  },
  {
    "question": "Which sorting algorithm is adaptive and works well with nearly sorted data?",
    "marks": 1,
    "mark_scheme": "Insertion sort",
    "topic": "Fundamentals of algorithms",
    "subtopic": "Sorting algorithms",
    "question_type": "multiple_choice",
    "wrong_choices": ["Bubble sort", "Merge sort", "Quick sort"]
  },
  {
    "question": "Which of the following has the fastest average-case performance for large data sets?",
    "marks": 1,
    "mark_scheme": "Quick sort",
    "topic": "Fundamentals of algorithms",
    "subtopic": "Sorting algorithms",
    "question_type": "multiple_choice",
    "wrong_choices": ["Bubble sort", "Insertion sort", "Selection sort"]
  },
  {
    "question": "Which data structure is commonly used for implementing recursion?",
    "marks": 1,
    "mark_scheme": "Stack",
    "topic": "Fundamentals of algorithms",
    "subtopic": "Recursion and structures",
    "question_type": "multiple_choice",
    "wrong_choices": ["Queue", "Linked list", "Heap"]
  },
  {
    "question": "Which algorithm would be most efficient for finding a single item in a large sorted dataset?",
    "marks": 1,
    "mark_scheme": "Binary search",
    "topic": "Fundamentals of algorithms",
    "subtopic": "Searching algorithms",
    "question_type": "multiple_choice",
    "wrong_choices": ["Linear search", "Bubble sort", "Merge sort"]
  },
  {
    "question": "Which sorting algorithm repeatedly selects the smallest item and moves it to the correct position?",
    "marks": 1,
    "mark_scheme": "Selection sort",
    "topic": "Fundamentals of algorithms",
    "subtopic": "Sorting algorithms",
    "question_type": "multiple_choice",
    "wrong_choices": ["Insertion sort", "Merge sort", "Quick sort"]
  },
  {
    "question": "What is the time complexity of selection sort?",
    "marks": 1,
    "mark_scheme": "O(n^2)",
    "topic": "Fundamentals of algorithms",
    "subtopic": "Sorting algorithms",
    "question_type": "multiple_choice",
    "wrong_choices": ["O(n)", "O(log n)", "O(n log n)"]
  },
  {
    "question": "Which type of algorithm guarantees finding the best possible solution?",
    "marks": 1,
    "mark_scheme": "Optimisation algorithm",
    "topic": "Fundamentals of algorithms",
    "subtopic": "Optimisation",
    "question_type": "multiple_choice",
    "wrong_choices": ["Heuristic algorithm", "Approximation algorithm", "Greedy algorithm"]
  }
]
